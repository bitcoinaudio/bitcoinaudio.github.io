"use strict";
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const dom5 = require("dom5/lib/index-next");
const polymer_analyzer_1 = require("polymer-analyzer");
const shady = require("shady-css-parser");
const rule_1 = require("../html/rule");
const registry_1 = require("../registry");
const util_1 = require("../util");
const p = dom5.predicates;
const isCustomStyle = p.AND(p.hasTagName('style'), p.OR(p.hasAttrValue('is', 'custom-style'), (node) => !!(node.parentNode && p.hasTagName('custom-style')(node.parentNode))));
class RootSelectorToHtml extends rule_1.HtmlRule {
    constructor() {
        super(...arguments);
        this.code = 'root-selector-to-html';
        this.description = util_1.stripIndentation(`
      Warns when using :root inside an element's template, custom-style, or style module.
  `);
    }
    checkDocument(parsedDocument, document) {
        return __awaiter(this, void 0, void 0, function* () {
            const elementStyleTags = [];
            const styleModuleStyleTags = [];
            // Get custom-styles
            const customStyleTags = [...dom5.queryAll(parsedDocument.ast, isCustomStyle, dom5.childNodesIncludeTemplate)];
            // Get dom-modules then sort style tags into element styles or style module
            // styles
            const domModules = document.getFeatures({ kind: 'dom-module' });
            if (domModules.size > 0) {
                for (const domModule of domModules) {
                    const moduleChildren = domModule.astNode.node.childNodes || [];
                    const template = moduleChildren.find((m) => m.tagName === 'template');
                    if (template === undefined ||
                        template.content.childNodes === undefined ||
                        template.content.childNodes.length === 0) {
                        continue;
                    }
                    const styleTag = template.content.childNodes.find((t) => t.tagName === 'style');
                    if (styleTag === undefined) {
                        continue;
                    }
                    const elements = document.getFeatures({ kind: 'polymer-element' });
                    const isElementModule = [...elements].some((el) => !!(el.sourceRange &&
                        polymer_analyzer_1.isPositionInsideRange(el.sourceRange.start, domModule.sourceRange)));
                    if (isElementModule) {
                        elementStyleTags.push(styleTag);
                    }
                    else {
                        styleModuleStyleTags.push(styleTag);
                    }
                }
            }
            return [
                ...this.generateWarnings(document, customStyleTags, 'html'),
                ...this.generateWarnings(document, elementStyleTags, ':host > *'),
                ...this.generateWarnings(document, styleModuleStyleTags, 'html, :host > *'),
            ];
        });
    }
    generateWarnings(document, styleTags, replacementText) {
        const warnings = [];
        if (styleTags.length === 0) {
            return warnings;
        }
        for (const style of styleTags) {
            const sourceRange = document.parsedDocument.sourceRangeForNode(style.childNodes && style.childNodes[0]);
            if (sourceRange === undefined) {
                continue;
            }
            const containingDoc = util_1.getDocumentContaining(sourceRange, document);
            if (containingDoc === undefined) {
                continue;
            }
            for (const node of containingDoc) {
                if (node.type !== shady.nodeType.ruleset) {
                    continue;
                }
                const deprecatedRegex = /:root/;
                const match = node.selector.match(deprecatedRegex);
                if (match === null) {
                    continue;
                }
                const start = node.range.start + match.index;
                const sourceRange = containingDoc.sourceRangeForShadyRange({ start, end: start + match[0].length });
                // Only fix plain `:root` selectors
                let fix = undefined;
                if (/^:root$/.test(node.selector)) {
                    fix = [{ range: sourceRange, replacementText }];
                }
                warnings.push(new polymer_analyzer_1.Warning({
                    parsedDocument: document.parsedDocument,
                    code: this.code,
                    severity: polymer_analyzer_1.Severity.WARNING, sourceRange,
                    message: util_1.stripWhitespace(`
            The ::root selector should no longer be used
          `),
                    fix
                }));
            }
        }
        return warnings;
    }
}
registry_1.registry.register(new RootSelectorToHtml());
//# sourceMappingURL=root-selector-to-html.js.map